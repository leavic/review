## 1. 静态导入

​		在import的时候可以在import后加上static关键字，这样可以将目标类下的所有静态成员引入，在使用的时候可以直接使用，而不用静态类.静态成员来调用

## 2. 可变参数

​		当某个方法需要不定数个参数时，可以在参数前类型后增加...来进行修饰，标志这个参数为可变参数。顾名思义，可变参数指的是用...来修饰的参数可以有不定个数的参数。实现原理是数组。注意：可变参数必须定义在参数列表的最后一个。

## 3. 增强for循环（编译后使用iterator进行编译）

​		格式为for(object : List<Object>){}，增强for循环的实现原理是利用了迭代器Iterator。增强for循环的优缺点：优点是让代码更为简洁。缺点：高级for循环遍历的必须是数组或者集合。这里需要注意：高级for循环不能对集合做操作，比如remove或者add。使用迭代器可以对数组使用remove方法，但是不能使用add

## 4. 自动封箱拆箱

​		八种基本数据类型分别为：byte,short,int,long,float,double,char,boolean，对应的封箱类型为Byte,Short,Integer,Long,Float,Double,Character,Boolean。包装之后的比较需要通过equals进行比较。整数包装类型的比较在-128～127之间时==可以正确的判断出来结果是否正确，但是在该范围之外则始终返回false。对于浮点类型来说，因为不存在缓存值所以始终返回false。而字符类型在0～127之间，超过该范围之后会始终返回false。

​		包装类型类似于String。其对象创建之后就不能修改。包装类也重写了equals方法，所以在使用时应该使用equals方法来进行判断。缓存机制是在对应的包装类中预先创建频繁使用的对象。当不再缓存范围内则创建对象并返回新创建的对象。否则则返回缓存范围内已经创建好的对象。

## 5. 枚举

​		enum即代表枚举，是在jdk1.5中新增的关键字。使用该关键字创建的类默认即成Enum类。1.5之后switch可以使用枚举类型。

## 6. 注解

​		注解实质上是在代码中的一种标记，这些标记可以在编译、类加载、运行时被读取。并且根据标记执行对应的代码。通过使用注解，编程人员可以在不改动原有代码的基础上在代码中添加新的逻辑。注解使用@interface来进行标记。

## 7. 泛型

​		泛型是指参数化类型，一说到参数，我们最常见的有定义在方法上的形参，也有调用方法时传递的实惨。而参数化类型就是将原油的类型参数化。然后在使用的时候传入具体的参数。从而确定类型。在1.5之前集合中可以存放任意对象，然后获取对象的时候必须要进行强制转换。这样就造成了不必要的风险。但是1.5之后在创建集合时可以将类型通过泛型传入。这样集合中只能放对应的对象。
​		泛型可以定义在类上、接口上、方法上

